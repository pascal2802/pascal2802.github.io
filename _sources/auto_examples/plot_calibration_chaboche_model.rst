
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_calibration_chaboche_model.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_calibration_chaboche_model.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_calibration_chaboche_model.py:


Calibrate Chaboche model using ABCCalibration Class
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 7-18

This example aims to illustrate the use of the ABCCalibration class with the Chaboche model
We recall that the Chaboche model is the following :

.. math::
  \sigma = G(\epsilon,R,C,\gamma) = R + \frac{C}{\gamma} (1-\exp(-\gamma\epsilon))

where:

- :math:`\epsilon` is the strain,
- :math:`\sigma` is the stress (Pa),
- :math:`R`, :math:`C`, :math:`\gamma` are the parameters.

.. GENERATED FROM PYTHON SOURCE LINES 21-22

| Loading python modules

.. GENERATED FROM PYTHON SOURCE LINES 24-38

.. code-block:: Python

    import openturns as ot
    from openturns.usecases import chaboche_model
    import math
    import imp
    import otABCCalibration.ABC_ClassProto as otABCC
    import openturns.viewer as otv
    import matplotlib.pyplot as plt
    import openturns.viewer as otv


    imp.reload(otABCC)

    # ot.Log.Show(ot.Log.NONE)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/d54380/Logiciels/OpenTURNS/otABCCalibration/doc/examples/plot_calibration_chaboche_model.py:27: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
      import imp

    <module 'otABCCalibration.ABC_ClassProto' from '/home/d54380/Logiciels/OpenTURNS/otABCCalibration/otABCCalibration/ABC_ClassProto.py'>



.. GENERATED FROM PYTHON SOURCE LINES 39-47

Define the Observations
==================================================
In practice, we generally use a data set which has been obtained from
measurements.
This data set can be loaded using e.g. :meth:`~openturns.Sample.ImportFromCSVFile`.
Here we import the data from the
:class:`~openturns.usecases.chaboche_model.ChabocheModel`
class.

.. GENERATED FROM PYTHON SOURCE LINES 47-53

.. code-block:: Python

    cm = chaboche_model.ChabocheModel()
    print(cm.data)
    observedParameters = cm.data[:, 0]  # Strain
    observedVariables = cm.data[:, 1]  # Stress
    numberOfObservations = cm.data.getSize()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

        [ Strain      Stress (Pa) ]
    0 : [ 0           7.56e+08    ]
    1 : [ 0.0077      7.57e+08    ]
    2 : [ 0.0155      7.85e+08    ]
    3 : [ 0.0233      8.19e+08    ]
    4 : [ 0.0311      8.01e+08    ]
    5 : [ 0.0388      8.42e+08    ]
    6 : [ 0.0466      8.49e+08    ]
    7 : [ 0.0544      8.79e+08    ]
    8 : [ 0.0622      8.85e+08    ]
    9 : [ 0.07        8.96e+08    ]




.. GENERATED FROM PYTHON SOURCE LINES 54-58

Set Calibration prior distribution
--------------------------------------------------
The prior observed parameters uncertainty distribution parameter is set
random uncertainty will be add to the observed parameters sample while evaluated ABC DOE.

.. GENERATED FROM PYTHON SOURCE LINES 58-62

.. code-block:: Python

    StrainUdistribution = ot.Normal(0, 0.001)
    distributionUObsParameters = ot.ComposedDistribution([StrainUdistribution])
    distributionUObsParameters.setDescription([r"$U_{\varepsilon}$"])








.. GENERATED FROM PYTHON SOURCE LINES 63-64

Define the prior joint distribution of the parameter to calibrate :math:`\pi(\theta)`

.. GENERATED FROM PYTHON SOURCE LINES 64-76

.. code-block:: Python


    Rdistribution = ot.Uniform(500.0e6, 800.0e6)
    Cdistribution = ot.Uniform(1000.0e6, 7000.0e6)
    gammaDistribution = ot.Uniform(1.0, 15.0)
    distributionParameters = ot.ComposedDistribution(
        [Rdistribution, Cdistribution, gammaDistribution]
    )
    distributionParameters.setDescription(["R", "C", r"$\gamma$"])

    thetaPrior = distributionParameters.getMean()
    print(thetaPrior)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [6.5e+08,4e+09,8]




.. GENERATED FROM PYTHON SOURCE LINES 77-78

Build a joint distribution between parameters to calibrate prior and observed parameter uncertainty prior

.. GENERATED FROM PYTHON SOURCE LINES 78-85

.. code-block:: Python


    distributionInputs = ot.ComposedDistribution(
        [StrainUdistribution, Rdistribution, Cdistribution, gammaDistribution]
    )
    distributionInputs.setDescription([r"$U_{\varepsilon}$", "R", "C", r"$\gamma$"])









.. GENERATED FROM PYTHON SOURCE LINES 86-89

Set the calibration criteria
==================================================
modeller need to define the computation of the criteria to define a calibrated model based on the returned sample by the evaluation of all the observation point

.. GENERATED FROM PYTHON SOURCE LINES 89-128

.. code-block:: Python



    def computeABCCriteria(samplePrediction, observedVariableSample):
        """
        function to compute criteria that will be used for ABC calibration
        In future ABC class calibration, function to be provided by modeller

        Parameters
        ---------
        samplePrediction : :class:`~openturns.Sample`
            Take as input the return sample from the evaluation of _exec function for all the point in the sample of observed parameters for a given candidate point of ParameterToCalibrate



        Returns
        -------
        pointCriteria : :class:`~openturns.Point`

        for a given ParamterToCalibrate Point, return a point with computed criteria (typically CvRMSE, NMBE)
        """

        residuals = samplePrediction - observedVariableSample

        pointCriteria = ot.Point(4)

        # compute RMSE
        RMSE_stress = math.sqrt(residuals.computeRawMoment(2)[0])
        MBE_stress = residuals.computeMean()[0]
        CvRMSE_stress = RMSE_stress / (observedVariableSample).computeMean()[0]
        NMBE_stress = MBE_stress / (observedVariableSample).computeMean()[0]

        pointCriteria[0] = RMSE_stress
        pointCriteria[1] = MBE_stress
        pointCriteria[2] = CvRMSE_stress
        pointCriteria[3] = NMBE_stress

        return pointCriteria









.. GENERATED FROM PYTHON SOURCE LINES 129-130

test the function with the :math:`\theta_{prior}` computed above

.. GENERATED FROM PYTHON SOURCE LINES 130-137

.. code-block:: Python

    calibratedIndices = [1, 2, 3]
    mycf = ot.ParametricFunction(cm.model, calibratedIndices, thetaPrior)
    priorPrediction = mycf(observedParameters)
    priorCriteria = computeABCCriteria(priorPrediction, observedVariables)
    print(priorCriteria)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [6.5104e+07,-6.09803e+07,0.0787326,-0.0737456]




.. GENERATED FROM PYTHON SOURCE LINES 138-141

Calibrate the model with ABC
--------------------------------------------------
The ABC method calibrate the model by sample conditioning

.. GENERATED FROM PYTHON SOURCE LINES 141-176

.. code-block:: Python

    observedParameterIndices = [0]
    toCalibrateParameterIndices = [1, 2, 3]
    observedOutputIndices = [0]
    doeSize = 15000  # Size of the prior MonteCarlo sample
    posteriorSampleTargetedSize = 100  # Targegeted size of the posterior conditional sample
    minCvRMSE = 0.0
    minNMBE = -0.005
    maxCvRMSE = 0.025
    maxNMBE = 0.005
    criteriaSelection = ot.Interval(
        [0, 0, minCvRMSE, minNMBE],
        [0, 0, maxCvRMSE, maxNMBE],
        [False, False, True, True],
        [False, False, True, True],
    )
    algo = otABCC.ABCCalibration(
        cm.model,
        computeABCCriteria,
        observedParameterIndices,
        toCalibrateParameterIndices,
        observedOutputIndices,
        observedParameters,
        observedVariables,
        distributionUObsParameters,
        distributionParameters,
        distributionInputs,
        doeSize,
        posteriorSampleTargetedSize,
        criteriaSelection,
    )
    algo.setABCCriteriaDescription(
        [r"$RMSE_{\sigma}$", r"$MBE_{\sigma}$", r"$CvRMSE_{\sigma}$", r"$NMBE_{\sigma}$"]
    )
    algo.run()








.. GENERATED FROM PYTHON SOURCE LINES 177-178

Investigate the results

.. GENERATED FROM PYTHON SOURCE LINES 178-181

.. code-block:: Python

    result = algo.getResult()
    print(algo.getPriorDOE())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

            [ $U_{\varepsilon}$ R                 C                 $\gamma$          ]
        0 : [  0.000608202       5.87782e+08       6.27061e+09       4.45299          ]
        1 : [ -0.00126617        7.96724e+08       1.51582e+09      11.1298           ]
        2 : [ -0.000438266       6.61966e+08       4.67719e+09      14.2451           ]
    ...
    14997 : [ -8.48901e-05       7.95249e+08       1.30474e+09       5.64843          ]
    14998 : [  0.000363987       7.52842e+08       3.72107e+09       8.93627          ]
    14999 : [  0.000211898       5.65989e+08       3.66711e+09       1.57779          ]




.. GENERATED FROM PYTHON SOURCE LINES 182-185

draw posterior input distribution to analyse calibration
it can be seen that :math:`\gamma` cannot be idenfied accurately but that some correlation with 
the two other parameters are present. 

.. GENERATED FROM PYTHON SOURCE LINES 185-189

.. code-block:: Python

    grid = result.conditionalSample.drawPosteriorInputDistribution()
    fig = otv.View(grid)
    fig.show()




.. image-sg:: /auto_examples/images/sphx_glr_plot_calibration_chaboche_model_001.png
   :alt: Conditional Sample : 160 out of 15000   0.000 < $CvRMSE_{\sigma}$ < 0.025   -0.005 < $NMBE_{\sigma}$ < 0.005 , Spearman : -0.10, Spearman : 0.02, Spearman : 0.08, Spearman : -0.10, Spearman : -0.92, Spearman : -0.20, Spearman : 0.02, Spearman : -0.92, Spearman : 0.51, Spearman : 0.08, Spearman : -0.20, Spearman : 0.51
   :srcset: /auto_examples/images/sphx_glr_plot_calibration_chaboche_model_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 190-192

on the new picture, the residuals distribution of the computed optimal point (the point that maximise the posterior input distribution infered from the empiric posterior sample) is analysed. 
the figure suggets that the discrepencies between model prediction and observed output are mostly due to measurment erros as the residuals are gaussian and centered.

.. GENERATED FROM PYTHON SOURCE LINES 192-199

.. code-block:: Python

    print(result.getParameterMAP())
    grid = result.drawResiduals()
    fig = otv.View(grid)
    fig.show()
    grid = result.drawObservationsVsPredictions()
    fig = otv.View(grid) 
    fig.show()



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/images/sphx_glr_plot_calibration_chaboche_model_002.png
         :alt: Residual analysis
         :srcset: /auto_examples/images/sphx_glr_plot_calibration_chaboche_model_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/images/sphx_glr_plot_calibration_chaboche_model_003.png
         :alt: plot calibration chaboche model
         :srcset: /auto_examples/images/sphx_glr_plot_calibration_chaboche_model_003.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [-9.1923e-05,7.45749e+08,2.85587e+09,8.34902]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 6.762 seconds)


.. _sphx_glr_download_auto_examples_plot_calibration_chaboche_model.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_calibration_chaboche_model.ipynb <plot_calibration_chaboche_model.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_calibration_chaboche_model.py <plot_calibration_chaboche_model.py>`
